module AssetAggregator
  module Aggregators
    # A #ClassInlinesAggregator includes fragments that are generated by an actual
    # Ruby class. That is, it allows inlining content into a class; at aggregation
    # time, the class is loaded by the #ClassInlinesAggregator, and one or more
    # methods are called on that class (if present). These methods, which are
    # type-specific (that is, a given method can only return content for one
    # #AggregateType), can each return zero or more pairs of (content, line number);
    # any content returned is aggregated up into the system.
    class ClassInlinesAggregator < AssetAggregator::Core::Aggregator
      # Creates a new instance.
      #
      # * +root+ is the root directory under which classes should be aggregated.
      # * +options+ can contain any of:
      #    * +methods_for_file_proc+: gets passed each file under the root; it should
      #      return an Array of all methods that could have data for an aggregator
      #      of this type for this file. (It can also return nil, or a single method --
      #      that is, just a symbol, not wrapped in an Array.) If not passed, we use
      #      :aggregated_javascript for Javascript and :aggregated_css for CSS.
      #      Note that this is called for _all_ files under the +root+, not just
      #      +.rb+ files, so you need to filter on that yourself, if required.
      #    * +file_to_class_proc+: for any file that has one or more methods that
      #      could contain content, gets called with the file path; it should return
      #      the Class object that that file represents, or raise an exception if it
      #      can't be loaded. This is necessary because, while there are conventions
      #      that map filename -> class name in Rails, it is not guaranteed. By default,
      #      we assume Rails conventions -- so +<root>/foo/bar/baz.rb+ should, when
      #      loaded, let us use +Foo::Bar::Baz+. We additionally allow the root itself
      #      to be used as a prefix, since a common case is having +app/views+ be the
      #      root, and using Erector widgets; to avoid namespace collisions, an
      #      Erector widget in +app/views/foo/bar/baz.rb+ defines a class named
      #      +Views::Foo::Bar::Baz+.
      #    * +class_prefix+: Only applicable if +file_to_class_proc+ is not specified.
      #      The supplied prefix wil be prepended to all class names before we try
      #      to locate them; this lets you specify, e.g., +app/views/foo/bar+ as your
      #      +root+, and then load classes successfully by setting this to +Foo::Bar::+.
      # * +subpath_definition_proc+ (the block passed to this constructor) -- for more
      #     information, see the #FilesAggregator; it works identically in this respect.
      #
      # Methods:
      # 
      # This is probably obvious, but the methods called are methods on the _class_,
      # not instance methods. We're aggregating content in these files, potentially only
      # once (e.g., in production), so there's no way we could even create an instance.
      # As a better example, the Javascript and CSS you may want to aggregate (e.g., from
      # Erector widgets) has to be independent of the actual request being served, because
      # it might only get run once. This is parallel to the #FilesAggregator.
      #
      # The methods called must return either +nil+ (if they don't want to return data),
      # or an array of zero or more subarrays. Each subarray must contain exactly two
      # elements: the first must be the actual content to be aggregated (as a String),
      # and the second must be the line number in the class that should be referenced
      # in the generated #Fragment -- that is, typically the line number on which the
      # content was declared. The line number can be set to +nil+ if the content
      # should be attributed to the class as a whole; however, it cannot be absent (that
      # is, the subarray must still have exactly two elements).
      #
      # Remember that a #Fragment is uniquely identified by file and line; if you return
      # multiple subarrays with the same line number, they will collide, and only one
      # of the pieces of content will actually get aggregated. Don't do this.
      def initialize(aggregate_type, file_cache, filters, root, options = { }, &subpath_definition_proc)
        super(aggregate_type, file_cache, filters)
        
        @methods_for_file_proc = options[:methods_for_file_proc] || method(:default_methods_for_file)
        @file_to_class_proc = options[:file_to_class_proc] || method(:default_file_to_class)
        @class_prefix = options[:class_prefix] || ""
        
        @root = File.expand_path(root)
        @subpath_definition_proc = subpath_definition_proc || method(:default_subpath_definition)
      end
      
      # A nice human-readable description.
      def to_s
        ":class_inlines, \'#{AssetAggregator::Core::SourcePosition.trim_rails_root(@root)}\', ..."
      end

      private
      # The default method we use if no +:file_to_class_proc+ is supplied to the constructor.
      # Simply uses Rails' naming conventions to map file to class name; the vast majority of
      # this time, this works fine. See the comment in the constructor for more details.
      def default_file_to_class(file_path)
        full_file_path = file_path.dup
        file_path = file_path[(@root.length + 1)..-1] if file_path[0..(@root.length - 1)].downcase == @root.downcase
        file_path = $1 if file_path =~ /^(.*)\.[^\/]+/
        
        klass = nil
        tries = [ file_path, File.join(File.basename(@root), file_path) ].map { |f| @class_prefix + f.camelize }
        load_errors = [ ]
        tries.each do |try|
          begin
            begin
              klass = try.constantize
            rescue Exception => e
              load full_file_path
              klass = try.constantize
            end
          rescue LoadError => le
            load_errors << le
          rescue NameError => ne
            load_errors << ne
          rescue Exception => e
            raise %{The AssetAggregator is trying to load the class in the file
'#{full_file_path}',
in order to see if it has assets (e.g., CSS, Javascript, etc.) inline in its code
that need to be aggregated.

We either couldn't load the file, or loaded it and then couldn't load the
class named #{try}.
Does the class have a syntax error, is it named wrong, or some other issue?
The exception we got was:

#{e} (#{e.class.name})
#{e.backtrace.join("\n")}

}
          end
          
          return klass if klass
        end
        
        raise "Can't find class that '#{file_path}' maps to; tried: #{tries.inspect}. We got the following errors:\n\n#{load_errors.map { |e| e.to_s + "\n" + e.backtrace.join("\n") }.join("\n\n")}"
      end
      
      # The default value for the +methods_for_file_proc+. Behaves as specified in the
      # constructor comment.
      def default_methods_for_file(filename)
        if filename =~ /\.rb$/i
          case aggregate_type.type
          when :javascript then :aggregated_javascript
          when :css then :aggregated_css
          else raise "We don't know what method to call on a class to get aggregated content of type #{aggregate_type.type.inspect}; you must pass a :methods_for_file function to the constructor"
          end
        end
      end
      
      # Given a file and the methods to call on it, calls the methods, extracts the content
      # from them, and adds the resulting #Fragment objects to our fragment set. Pretty
      # straightforward.
      def extract_fragments_from_file(file, methods)
        klass = @file_to_class_proc.call(file)
        mtime = @filesystem_impl.mtime(file)
        
        methods.each do |method|
          next unless klass.respond_to?(method)
          (klass.send(method) || [ ]).each do |(content, line_number)|
            raise "You must supply a numeric line number, not #{line_number.inspect}" if line_number && (! line_number.kind_of?(Integer))
            
            target_subpaths = @subpath_definition_proc.call(file, content)
            source_position = AssetAggregator::Core::SourcePosition.new(file, line_number)
            fragment = AssetAggregator::Core::Fragment.new(target_subpaths, source_position, content, mtime)
            fragment_set.add(fragment)
          end
        end
      end
      
      # Called by the superclass; traverses the +root+, calling the +methods_for_file_proc+ on
      # each one, and loads the requisite fragments from each one.
      def refresh_fragments_since(last_refresh_fragments_since_time)
        @file_cache.changed_files_since(@root, last_refresh_fragments_since_time).each do |changed_file|
          next if File.basename(changed_file) =~ /^\./ || @filesystem_impl.directory?(changed_file)
          
          methods = Array(@methods_for_file_proc.call(changed_file)).compact
          if methods && (! methods.empty?)
            fragment_set.remove_all_for_file(changed_file)
            extract_fragments_from_file(changed_file, Array(methods)) if @filesystem_impl.exist?(changed_file)
          end
        end
      end
    end
  end
end
