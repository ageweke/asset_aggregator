module AssetAggregator
  module OutputHandlers
    # An #AssetAggregator::Core::OutputHandler that writes output in a flexible
    # form that's compatible with Javascript and CSS both.
    class CommonOutputHandler < AssetAggregator::Core::OutputHandler
      def extension
        raise "You must instantiate a subclass that overrides #extension"
      end
      
      def start_all
        case options[:header_comment]
        when nil, :none, false then
          # nothing
        when :brief then
          output "/* '#{subpath}.#{extension}' */"
        when :full then
          output <<-END
/************************************************************************
 * '#{subpath}.#{extension}'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * This version was generated at #{Time.now}
 ************************************************************************/
END
        else
          raise "Unknown header comment option #{options[:header_comment].inspect}"
        end
      end

      def start_aggregator(aggregator)
        case options[:aggregator_comment]
        when nil, :none, false then
          # nothing
        when :brief then
          output "/* #{aggregator} */"
        when :encrypted then
          output "/* #{encrypt(aggregator)} */"
        when :full then
          output <<-END


/************************************************************************
 * #{aggregator}
 ************************************************************************/

END
        else
          raise "Unknown aggregator comment option #{options[:aggregator_comment].inspect}"
        end
      end
      
      def start_fragment(aggregator, fragment)
        case options[:fragment_comment]
        when nil, :none, false then
          # nothing
        when :brief then
          output "/* #{fragment.source_position} */"
        when :encrypted then
          output "/* #{encrypt(fragment.source_position)} */"
        when :full then
          output <<-END
/* ----------------------------------------------------------------------
   - #{fragment.source_position}
   ---------------------------------------------------------------------- */
END
        else
          raise "Unknown fragment comment option #{options[:fragment_comment].inspect}"
        end
      end
      
      class << self
        def cipher(mode, key)
          @ciphers ||= { }
          @ciphers[ [ mode, key ] ] ||= begin
            cipher = OpenSSL::Cipher::Cipher.new('aes-256-cbc')
            cipher.send(mode)
            cipher.key = Digest::SHA256.digest(key)
            cipher
          end
        end

        def run_cipher(mode, key, data)
          cipher = cipher(mode, key)
          output = cipher.update(data)
          output << cipher.final
          output
        end

        def encrypt(secret, plaintext)
          if @encrypted_secret != secret
            @encrypted = { }
            @encrypted_secret = secret
          end
          
          @encrypted[plaintext] ||= begin
            out = Base64.encode64(run_cipher(:encrypt, secret, plaintext)).gsub(/[\r\n]+/, '')
            encrypted(plaintext, out)
            out
          end
        end
        
        def on_encryption(&proc)
          # We use a global variable here, rather than a class variable, because
          # in development mode our class gets reloaded on every single request.
          $_asset_aggregator_common_output_handler_on_encryption = proc
        end
        
        def encrypted(plaintext, ciphertext)
          $_asset_aggregator_common_output_handler_on_encryption.call(plaintext, ciphertext) if $_asset_aggregator_common_output_handler_on_encryption
        end
      end
      
      private
      def encrypt(s)
        raise "You must specify an encryption secret with :secret" unless options[:secret]
        self.class.encrypt(options[:secret], s.to_s)
      end
    end
  end
end
