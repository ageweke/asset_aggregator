module AssetAggregator
  module OutputHandlers
    # An #AssetAggregator::Core::OutputHandler that writes output in a flexible
    # form that's compatible with Javascript and CSS both.
    #
    # This takes various options to indicate how you like your output -- passed
    # in the constructor, as the last parameter, but more commonly set by (e.g.)
    #   AssetAggregator.output_options[:header_comment] = :brief
    #
    # The available options are:
    #
    # * +:header_comment+ -- what should the comment at the very top of the output
    #   file look like? +:none+ for none at all, +:brief+ for something like
    #   +/* 'foo.js' @ 1262117701 */+, or +:full+ for something much more detailed.
    #   Default: +:full+ in development mode, +:none+ otherwise.
    # * +:aggregator_comment+ -- what should the comment before each aggregator's
    #   output fragments look like? +:none+ for none at all, +:brief+ for 
    #   just the aggregator's string, +:full+ for that decorated by lines of
    #   asterisks, or +:encrypted+ for an encrypted version of +:brief+.
    # * +:fragment_comment+ -- what should the comment above each output fragment
    #   look like? +:none+ for none at all, +:brief+ for just the file (and line,
    #   if applicable), +:full+ for that decorated by lines of hyphens, or
    #   +:encrypted+ for an encrypted version of +:full+.
    #
    # = Encryption
    #
    # If you set any option to +:encrypted+, then you must also provide an 
    # encryption secret with +:secret+. This is then used to encrypt the comment
    # in question, using OpenSSL's aes-256-cbc cipher and a Base64 encoding.
    # This prevents revealing information about the structure of your code in
    # your aggregates. To decrypt, you can pass the resulting
    # Base64-encoded string to +CommonOutputHandler.decrypt(secret, ciphertext)+.
    # 
    # However, you can also register a block that gets called on each encryption
    # event (which should be rare; we cache the plaintext->ciphertext mappings,
    # for speed) by passing it to AssetAggregator#on_encryption. It will get called
    # each time something is encrypted; it'll be passed the plaintext and resulting
    # Base64-encoded ciphertext. You can then use this to build up a dictionary
    # of ciphertext->plaintext mappings, for later decoding.
    class CommonOutputHandler < AssetAggregator::Core::OutputHandler
      def extension
        raise "You must instantiate a subclass that overrides #extension"
      end
      
      def start_all
        case options[:header_comment]
        when nil, :none, false then
          # nothing
        when :brief then
          output "/* '#{subpath}.#{extension}' @ #{Time.now.to_i} */"
        when :full then
          output <<-END
/************************************************************************
 * '#{subpath}.#{extension}'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * This version was generated at #{Time.now}
 ************************************************************************/
END
        else
          raise "Unknown header comment option #{options[:header_comment].inspect}"
        end
      end

      def start_aggregator(aggregator)
        case options[:aggregator_comment]
        when nil, :none, false then
          # nothing
        when :brief then
          output "/* #{aggregator} */"
        when :encrypted then
          output "/* #{encrypt(aggregator)} */"
        when :full then
          output <<-END


/************************************************************************
 * #{aggregator}
 ************************************************************************/

END
        else
          raise "Unknown aggregator comment option #{options[:aggregator_comment].inspect}"
        end
      end
      
      def start_fragment(aggregator, fragment)
        case options[:fragment_comment]
        when nil, :none, false then
          # nothing
        when :brief then
          output "/* #{fragment.source_position} */"
        when :encrypted then
          output "/* #{encrypt(fragment.source_position)} */"
        when :full then
          output <<-END
/* ----------------------------------------------------------------------
   - #{fragment.source_position}
   ---------------------------------------------------------------------- */
END
        else
          raise "Unknown fragment comment option #{options[:fragment_comment].inspect}"
        end
      end
      
      class << self
        def cipher(mode, key)
          @ciphers ||= { }
          @ciphers[ [ mode, key ] ] ||= begin
            cipher = OpenSSL::Cipher::Cipher.new('aes-256-cbc')
            cipher.send(mode)
            cipher.key = Digest::SHA256.digest(key)
            cipher
          end
        end

        def run_cipher(mode, key, data)
          cipher = cipher(mode, key)
          output = cipher.update(data)
          output << cipher.final
          output
        end

        def encrypt(secret, plaintext)
          if @encrypted_secret != secret
            @encrypted = { }
            @encrypted_secret = secret
          end
          
          @encrypted[plaintext] ||= begin
            out = Base64.encode64(run_cipher(:encrypt, secret, plaintext)).gsub(/[\r\n]+/, '')
            encrypted(plaintext, out)
            out
          end
        end
        
        def decrypt(secret, ciphertext)
          run_cipher(:decrypt, secret, Base64.decode64(ciphertext))
        end
        
        def on_encryption(&proc)
          # We use a global variable here, rather than a class variable, because
          # in development mode our class gets reloaded on every single request.
          $_asset_aggregator_common_output_handler_on_encryption = proc
        end
        
        def encrypted(plaintext, ciphertext)
          $_asset_aggregator_common_output_handler_on_encryption.call(plaintext, ciphertext) if $_asset_aggregator_common_output_handler_on_encryption
        end
      end
      
      private
      def encrypt(s)
        raise "You must specify an encryption secret with :secret" unless options[:secret]
        self.class.encrypt(options[:secret], s.to_s)
      end
    end
  end
end
